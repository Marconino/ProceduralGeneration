#pragma kernel GenerateMarchingCubes
#pragma kernel Terraforming

#include "MarchingCubesTable.hlsl"

struct Triangle
{
    float3 A;
    float3 B;
    float3 C;
};

int _nbPointsPerChunk;
float _IsoValue;
RWStructuredBuffer<float> _DensityValues;
AppendStructuredBuffer<Triangle> _Triangles;

float3 _HitPos;
float _RadiusTerraforming;
float _TerraformStrength;
float3 _ChunkPos;
int _ChunkAxisSize;

int GetIndexFromPos(int x, int y, int z);
float3 GetVerticesOffset(int i);
float3 Interpolation(float3 _cood1, float _density1, float3 _cood2, float _density2);

[numthreads(8, 8, 8)]
void GenerateMarchingCubes(uint3 id : SV_DispatchThreadID)
{
    float3 pos = id;
    if (pos.x >= _nbPointsPerChunk - 1 || pos.y >= _nbPointsPerChunk - 1 || pos.z >= _nbPointsPerChunk - 1)
    {
        return;
    }
    
    int flagIndex = 0;
    float currDensityValues[8];
    
    for (int i = 0; i < 8; i++)
    {
        float3 nextPos = pos + verticesOffsets[i];
        currDensityValues[i] = _DensityValues[GetIndexFromPos(nextPos.x, nextPos.y, nextPos.z)];

        if (currDensityValues[i] < _IsoValue)
            flagIndex |= 1 << i;
    }

    int edges[] = triTable[flagIndex];

    for (int j = 0; edges[j] != -1; j += 3)
    {
        int firstEdgeVertex0 = edgeVertices[edges[j]][0];
        int firstEdgeVertex1 = edgeVertices[edges[j]][1];
        
        int secondEdgeVertex0 = edgeVertices[edges[j + 1]][0];
        int secondEdgeVertex1 = edgeVertices[edges[j + 1]][1];
        
        int thirdEdgeVertex0 = edgeVertices[edges[j + 2]][0];
        int thirdEdgeVertex1 = edgeVertices[edges[j + 2]][1];

        Triangle currTriangle;
        
        //currTriangle.A = Interpolation(verticesOffsets[firstEdgeVertex0] + pos, currDensityValues[firstEdgeVertex0],
        //                               verticesOffsets[firstEdgeVertex1] + pos, currDensityValues[firstEdgeVertex1]);
        //currTriangle.B = Interpolation(verticesOffsets[secondEdgeVertex0] + pos, currDensityValues[secondEdgeVertex0],
        //                               verticesOffsets[secondEdgeVertex1] + pos, currDensityValues[secondEdgeVertex1]);
        //currTriangle.C = Interpolation(verticesOffsets[thirdEdgeVertex0] + pos, currDensityValues[thirdEdgeVertex0],
        //                               verticesOffsets[thirdEdgeVertex1] + pos, currDensityValues[thirdEdgeVertex1]);

        currTriangle.A = ((verticesOffsets[firstEdgeVertex0] + verticesOffsets[firstEdgeVertex1]) / 2) + pos;
        currTriangle.B = ((verticesOffsets[secondEdgeVertex0] + verticesOffsets[secondEdgeVertex1]) / 2) + pos;
        currTriangle.C = ((verticesOffsets[thirdEdgeVertex0] + verticesOffsets[thirdEdgeVertex1]) / 2) + pos;
        
        //Scaling   
        currTriangle.A = (currTriangle.A / (_nbPointsPerChunk - 1)) * _ChunkAxisSize;
        currTriangle.B = (currTriangle.B / (_nbPointsPerChunk - 1)) * _ChunkAxisSize;
        currTriangle.C = (currTriangle.C / (_nbPointsPerChunk - 1)) * _ChunkAxisSize;
        
        //Centering
        currTriangle.A -= _ChunkAxisSize / 2.0;
        currTriangle.B -= _ChunkAxisSize / 2.0;
        currTriangle.C -= _ChunkAxisSize / 2.0;
        
        _Triangles.Append(currTriangle);
    }
}

[numthreads(8, 8, 8)]
void Terraforming(uint3 id : SV_DispatchThreadID)
{
    float3 pos = id;

    
    //pos.x = (pos.x / (_nbPointsPerChunk - 1)) * _ChunkSize;
    //pos.y = (pos.y / (_nbPointsPerChunk - 1)) * _ChunkSize;
    //pos.z = (pos.z / (_nbPointsPerChunk - 1)) * _ChunkSize;
    
    //_ChunkPos.x -= (_ChunkSize / 2.0) -_RadiusTerraforming / 2.0;
    //_ChunkPos.y -= (_ChunkSize / 2.0) -_RadiusTerraforming / 2.0;
    //_ChunkPos.z -= (_ChunkSize / 2.0) -_RadiusTerraforming / 2.0;
    
    if (distance(_ChunkPos + float3(pos.x - _ChunkAxisSize / 2.0, pos.y - _ChunkAxisSize / 2.0, pos.z - _ChunkAxisSize / 2.0), _HitPos) <= _RadiusTerraforming)
    {
        _DensityValues[GetIndexFromPos(pos.x, pos.y, pos.z)] += _TerraformStrength;
    }
}

int GetIndexFromPos(int x, int y, int z)
{
    return x + _nbPointsPerChunk * (y + _nbPointsPerChunk * z);
}

float3 Interpolation(float3 _cood1, float _density1, float3 _cood2, float _density2)
{
    float t = _IsoValue - _density1 / (_density2 - _density1);
    return _cood1 + t * (_cood2 - _cood1);
}